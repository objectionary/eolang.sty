%%
%% This is file `eolang.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% eolang.dtx  (with options: `package')
%% (The MIT License)
%% 
%% Copyright (c) 2021-2022 Yegor Bugayenko
%% 
%% Permission is hereby granted, free of charge, to any person obtaining a copy
%% of this software and associated documentation files (the 'Software'), to deal
%% in the Software without restriction, including without limitation the rights
%% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
%% copies of the Software, and to permit persons to whom the Software is
%% furnished to do so, subject to the following conditions:
%% 
%% The above copyright notice and this permission notice shall be included in all
%% copies or substantial portions of the Software.
%% 
%% THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
%% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
%% SOFTWARE.



\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{eolang}
[0000-00-00 0.0.0 Formulas and Graphs for EO Programming Language]























\RequirePackage{stmaryrd}
\RequirePackage{amsmath}
\let\Bbbk\relax\RequirePackage{amssymb}
\RequirePackage{fancyvrb}
\RequirePackage{iexec}

\RequirePackage{pgfopts}
\RequirePackage{ifluatex}
\RequirePackage{ifxetex}
\pgfkeys{
  /eolang/.cd,
  tmpdir/.store in=\eolang@tmpdir,
  tmpdir/.default=_eolang\ifxetex-xe\else\ifluatex-lua\fi\fi,
  tmpdir
}
\ProcessPgfOptions{/eolang}

\iexec[null]{mkdir -p "\eolang@tmpdir/\jobname"}%

\makeatletter\newcounter{eolang@lineno}\makeatother

\RequirePackage{pdftexcmds}
\makeatletter
\newcommand\eolang@mdfive[1]{\pdf@filemdfivesum{#1}}
\makeatother

\makeatletter
\begin{VerbatimOut}{\eolang@tmpdir/eolang-phi.pl}
$env = $ARGV[0];
open(my $fh, '<', $ARGV[1]);
my $tex; { local $/; $tex = <$fh>; }
print '% This file is auto-generated', "\n";
print '% There are ', length($tex),
  ' chars in the input: ', $ARGV[1], "\n";
print '% ---', "\n";
if (index($tex, "\t") > 0) {
  print "TABS are prohibited!";
  exit 1;
}
my @lines = split (/\n/g, $tex);
foreach my $t (@lines) {
  print '% ', $t, "\n";
}
print '% ---', "\n";
if ($env eq 'phiq') {
  print '$';
} else {
  print '\begin{', $env, '}\begin{split}';
}
$tex =~ s/%.*\n/\n/g;
$tex =~ s/^\s+|\s+$//g;
if ($env ne 'phiq') {
  $tex =~ s/\s+\\\n\s*//g;
  $tex =~ s/\\\\\n/\n\n/g;
}
$tex =~ s/([\s,>\(])([0-9A-F][0-9A-F-]*)/\1|\2|/g;
$tex =~ s/\?/\\varnothing{}/g;
$tex =~ s/@/\\varphi{}/g;
$tex =~ s/&/\\sigma{}/g;
$tex =~ s/\^/\\rho{}/g;
$tex =~ s/\$/\\xi{}/g;
$tex =~ s/-([a-z]+)>/\\mathrel{\\xrightarrow{\\text{\\sffamily\\scshape \1}}}/g;
$tex =~ s/!->/\\mathrel{\\phiConst}/g;
$tex =~ s/->/\\mathrel{\\mapsto}/g;
$tex =~ s/~>/\\mathrel{\\phiWave}/g;
$tex =~ s/:=/\\mathrel{\\vDash}/g;
$tex =~ s/..>/\\mathrel{\\phiDotted}/g;
$tex =~ s/\|([^\|]+)\|/\\textnormal{\\texttt{\1}}{}/g;
$tex =~ s/\[\[/\\llbracket\\mathrel{}/g;
$tex =~ s/\]\]/\\mathrel{}\\rrbracket{}/g;
if ($env ne 'phiq') {
  $tex =~ s/\\begin\{split\}\n/\\begin{split}&/g;
  $tex =~ s/\n\s*\\end\{split\}/\\end{split}/g;
  $tex =~ s/\n\n/\\\\&/g;
  $tex =~ s/\n/\\\\[-4pt]&/g;
  $tex =~ s/([^&\s])\s{2}([^\s])/\1 \2/g;
  $tex =~ s/\s{2}/ \\quad{}/g;
  my @leads = $tex =~ /&[^\s]+\s/g;
  my @eols = $tex =~ /&/g;
  $tex = '&' . $tex;
  if (0+@leads == 0+@eols && 0+@eols > 0) {
    $tex =~ s/&([^\s]+)\s/\1&/g;
  }
}
print $tex;
if ($env eq 'phiq') {
  print '$';
} else {
  print '\end{split}\end{', $env, '}';
}
print '\endinput%';
\end{VerbatimOut}
\message{eolang: File with Perl script
  '\eolang@tmpdir/eolang-phi.pl' saved^^J}%
\iexec[trace,null]{perl -pi -e 's/(\\\\[a-zA-Z])\\s+/\\1/g'
  "\eolang@tmpdir/eolang-phi.pl"}
\makeatother

\makeatletter\newcommand\eolang@process[1]{
  \def\hash{\eolang@mdfive
    {\eolang@tmpdir/\jobname/phiquation.tex}}%
  \iexec[null]{cp "\eolang@tmpdir/\jobname/phiquation.tex"
    "\eolang@tmpdir/\jobname/\hash.tex"}%
  \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-post.tex]{
    perl "\eolang@tmpdir/eolang-phi.pl"
    '#1'
    "\eolang@tmpdir/\jobname/\hash.tex"}%
  \setcounter{FancyVerbLine}{\value{eolang@lineno}}%
}
\newenvironment{phiquation*}%
{\VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/phiquation.tex}}
{\end{VerbatimOut}\eolang@process{equation*}}
\newenvironment{phiquation}%
{\VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/phiquation.tex}}
{\end{VerbatimOut}\eolang@process{equation}}
\makeatother

\makeatletter\newcommand\phiq[1]{%
  \iexec[trace,quiet,stdout=\eolang@tmpdir/\jobname/phiq.tex]{
    /bin/echo '\detokenize{#1}'}%
  \def\hash{\eolang@mdfive
    {\eolang@tmpdir/\jobname/phiq.tex}}%
  \iexec[null]{cp "\eolang@tmpdir/\jobname/phiq.tex"
    "\eolang@tmpdir/\jobname/\hash.tex"}%
  \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-post.tex]{
    perl \eolang@tmpdir/eolang-phi.pl 'phiq'
    "\eolang@tmpdir/\jobname/\hash.tex"}%
}\makeatother

\makeatletter
\begin{VerbatimOut}{\eolang@tmpdir/eolang-sodg.pl}
sub num {
  my ($i) = @_;
  $i =~ s/(\+|-)\./\10./g;
  return $i;
}
sub fmt {
  my ($tex) = @_;
  $tex =~ s/\|([^\|]+)\|/\\textnormal{\\texttt{\1}}/g;
  return $tex;
}
open(my $fh, '<', $ARGV[0]);
my $tex; { local $/; $tex = <$fh>; }
if (index($tex, "\t") > 0) {
  print "TABS are prohibited!";
  exit 1;
}
print '% This file is auto-generated', "\n";
print '% There are ', length($tex),
  ' chars in the input: ', $ARGV[0], "\n";
print '% ---' . "\n";
foreach my $t (split (/\n/g, $tex)) {
  print '% ', $t, "\n";
}
print '% ---';
$tex =~ s/\\\\/\n/g;
$tex =~ s/(\\[a-zA-Z]+) +/\1/g;
$tex =~ s/\n{2,}/\n/g;
my @cmds = split(/\n/g, $tex);
print ' (' . $#cmds . " lines)\n";
print '\begin{phicture}', "\n";
for (my $c = 0; $c < $#cmds; $c++) {
  my $cmd = $cmds[$c];
  $cmd =~ s/^\s+//g;
  $cmd =~ s/%.*//g;
  my ($head, $tail) = split(/ /, $cmd, 2);
  my %opts = {};
  foreach my $p (split(/ /, $tail)) {
    my ($q, $t) = split(/:/, $p);
    $opts{$q} = $t;
  }
  if (index($head, '->') >= 0) {
    print '\draw[';
    if (exists $opts{'pi'}) {
      print ',phi-pi';
      if (not exists $opts{'a'}) {
        $opts{'a'} = '\pi';
      }
    }
    print ']';
    my ($from, $to) = split (/->/, $head);
    print ' (', $from, ') ';
    if (exists $opts{'bend'}) {
      print 'edge [bend right=', num($opts{'bend'}), ']';
    } else {
      print '--';
    }
    if (exists $opts{'rho'} or exists $opts{'rrho'}) {
      print ' pic[sloped,phi-rho]{parallel arrow={';
      print '-' if not exists $opts{'rrho'};
      print '0.3,-0.15}}';
    }
    if (exists $opts{'a'}) {
      my $a = $opts{'a'};
      if (index($a, '$') == -1) {
        $a = '$' . fmt($a) . '$';
      } else {
        $a = fmt($a);
      }
      print ' node [phi-attr] {', $a, '}';
    }
    print ' (', $to, ')';
  } elsif (index($head, '=>') >= 0) {
    my ($from, $to) = split (/=>/, $head);
    if ($from eq '') {
      print '\node [phi-arrow, left=.6cm of ' .
        $to . ']';
    } elsif ($to eq '') {
      print '\node [phi-arrow, right=.6cm of ' .
        $from . ']';
    } else {
      print '\node [phi-arrow] at ($(' .
        $from . ')!0.5!(' . $to . ')$)';
    }
    print '{}';
  } elsif (index($head, '!') >= 0) {
    my ($v, $marker) = split (/!/, $head);
    print '\node [phi-marker, left=.4cm of ' .
      $v . ']{' . fmt($marker) . '}';
  } elsif (index($head, '+') >= 0) {
    my ($v, $suffix) = split (/\+/, $head);
    my @friends = ($v);
    foreach my $c (@cmds) {
      $e = $c;
      $e =~ s/^\s+//g;
      my $h = substr($e, 0, index($e, ' '));
      foreach my $f (@friends) {
        my $add = '';
        if (index($h, $f . '->') >= 0) {
          $add = substr($h, index($h, '->') + 2);
        }
        if (index($e, '->' . $f . ' ') >= 0) {
          $add = substr($h, 0, index($h, '->'));
        }
        if (index($e, 'xy:' . $f . ',') >= 0) {
          $add = $h;
        }
        if (index($add, '+') == -1 and $add ne '' and not(grep(/^${add}$/, @friends))) {
          push(@friends, $add);
        }
      }
    }
    my @extra = ();
    foreach my $e (@cmds) {
      $m = $e;
      if ($m =~ /^\s?${v}\s/) {
        next;
      }
      foreach my $f (@friends) {
        my $h = $f;
        $h =~ s/[a-z]$//g;
        if ($m =~ s/^(\s*)${f}\+${suffix}\s?/\1${h}${suffix} /g) {
          last;
        }
        $m =~ s/^(\s*)${f}\s/\1${h}${suffix} /g;
        $m =~ s/^(\s*)${f}->/\1${h}${suffix}->/g;
        $m =~ s/\sxy:${f},/ xy:${h}${suffix},/g;
        $m =~ s/->${f}\s/->${h}${suffix} /g;
      }
      if ($m ne $e) {
        push(@extra, ' ' . $m);
      }
    }
    splice(@extra, 0, 0, @extra[-1]);
    splice(@extra, -1, 1);
    splice(@extra, 0, 0, '% clone of ' . $v . ' (' . $head .
      '), friends: [' . join(', ', @friends) . '] in ' .
      $#cmds . ' lines');
    splice(@cmds, $c, 1, @extra);
    print '% cloned ' . $v . ' at line no.' . $c .
      ' (+' . $#extra . ' lines -> ' .
      $#cmds . ' lines total)';
  } else {
    print '\node[';
    if (exists $opts{'xy'}) {
      my ($v, $right, $down) = split(/,/, $opts{'xy'});
      my $loc = '';
      if ($down > 0) {
        $loc = 'below ';
      } elsif ($down < 0) {
        $loc = 'above ';
      }
      if ($right > 0) {
        $loc = $loc . 'right';
      } elsif ($right < 0) {
        $loc = $loc . 'left';
      }
      print ',' . $loc . '=';
      print abs(num($down)) . 'cm and ' .
        abs(num($right)) . 'cm of ' . $v;
    }
    if (exists $opts{'data'}) {
      print ',phi-data';
      if (not $opts{'data'} eq '') {
        my $d = $opts{'data'};
        if (index($d, '|') == -1) {
          $d = '$\Delta\phiDotted\text{' .
            '\textnormal{\texttt{' . fmt($d) . '}}}$';
        } else {
          $d = fmt($d);
        }
        $opts{'box'} = $d;
      }
    } elsif (exists $opts{'atom'}) {
      print ',phi-atom';
      if (not $opts{'atom'} eq '') {
        my $a = $opts{'atom'};
        if (index($a, '$') == -1) {
          $a = '$\lambda\phiDotted{}' . fmt($a) . '$';
        } else {
          $a = fmt($a);
        }
        $opts{'box'} = $a;
      }
    } else {
      print ',phi-object';
    }
    print ']';
    print ' (', $head, ')';
    print ' {$';
    if (index($head, 'v0') == 0) {
      print '\Phi';
    } else {
      $name = $head;
      $name =~ s/^v/v_/g;
      $name =~ s/[^0-9]$//g;
      print $name;
    }
    print '$}';
    if (exists $opts{'box'}) {
      print ' node[phi-box] at (';
      print $head, '.south east) {';
      print $opts{'box'}, '}';
    }
  }
  print ";\n";
}
print '\end{phicture}%', "\n";
print "% after processing:\n% ---\n";
foreach my $c (@cmds) {
  print '% ', $c, "\n";
}
print '% --- (' . $#cmds . " lines)\n";
print '\endinput%';
\end{VerbatimOut}
\message{eolang: File with Perl script
  '\eolang@tmpdir/eolang-sodg.pl' saved^^J}%
\iexec[trace,null]{perl -pi -e 's/(\\\\[a-zA-Z])\\s+/\\1/g'
  "\eolang@tmpdir/eolang-sodg.pl"}
\makeatother

\setcounter{FancyVerbLine}{0}

\RequirePackage{tikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{shapes}
  \usetikzlibrary{decorations}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{intersections}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usetikzlibrary{shapes.arrows}

\newenvironment{phicture}%
  {\noindent\begin{tikzpicture}[
    ->,>=stealth',node distance=0,thick,
    pics/parallel arrow/.style={
      code={\draw[-latex,phi-rho] (##1) -- (-##1);}}]}%
  {\end{tikzpicture}}
\tikzstyle{phi-arrow} = [fill=white!80!black, single arrow,
  minimum height=0.5cm, minimum width=0.5cm,
  single arrow head extend=2mm]
\tikzstyle{phi-marker} = [inner sep=0pt, minimum height=1.4em,
  minimum width=1.4em, font={\small\color{white}\ttfamily},
  fill=gray]
\tikzstyle{phi-thing} = [thick,inner sep=0pt,minimum height=2.4em,
  draw,font={\small}]
\tikzstyle{phi-object} = [phi-thing,circle]
\tikzstyle{phi-data} = [phi-thing,regular polygon,
  regular polygon sides=8]
\tikzstyle{phi-empty} = [phi-object]
\tikzstyle{phi-rho} = [draw,decorate,decoration={
  snake,amplitude=.4mm,segment length=2mm,post length=1mm}]
\tikzstyle{phi-pi} = [draw,dotted]
\tikzstyle{phi-atom} = [phi-object,double]
\tikzstyle{phi-box} = [xshift=-5pt,yshift=3pt,draw,fill=white,
  rectangle,thin,minimum width=1.2em,anchor=north west,
  font={\scriptsize}]
\tikzstyle{phi-attr} = [midway,sloped,inner sep=0pt,
  above=2pt,sloped/.append style={transform shape},
  font={\scriptsize},color=black]

\makeatletter\newenvironment{sodg}%
{\VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/sodg.tex}}
{\end{VerbatimOut}%
  \def\hash{\eolang@mdfive
    {\eolang@tmpdir/\jobname/sodg.tex}}%
  \iexec[null]{cp "\eolang@tmpdir/\jobname/sodg.tex"
    "\eolang@tmpdir/\jobname/\hash.tex"}%
  \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-post.tex]{
    perl "\eolang@tmpdir/eolang-sodg.pl"
    "\eolang@tmpdir/\jobname/\hash.tex"}%
  \setcounter{FancyVerbLine}{\value{eolang@lineno}}%
}\makeatother

\newcommand\eolang{%
  \ifdefined\anon%
    \anon[XYZ]{{\sffamily EO}}%
  \else%
    {\sffamily EO}%
  \fi%
}

\RequirePackage{hyperref}
\newcommand\phic{%
  \ifdefined\anon%
    \anon[\texorpdfstring{$\alpha$}{a}-calculus]
      {\texorpdfstring{$\varphi$}{phi}-calculus}%
  \else%
    \texorpdfstring{$\varphi$}{phi}-calculus%
  \fi%
}

\newcommand\xmir{%
  \ifdefined\anon%
    \anon[XML']{XMIR}%
  \else%
    XMIR%
  \fi%
}

\newcommand\phiConst{%
  \mathrel{\hspace{.15em}}%
  \mapstochar\mathrel{\hspace{-.15em}}\mapsto}

\newcommand\phiWave{%
  \mapstochar\mathrel{\mspace{0.45mu}}\leadsto}

\RequirePackage{trimclip}
\RequirePackage{amsfonts}
\makeatletter
\newcommand{\phiDotted}{%
  \mapstochar\mathrel{\mathpalette\phiDotted@\relax}}
\newcommand{\phiDotted@}[2]{%
  \begingroup
  \settowidth{\dimen\z@}{$\m@th#1\rightarrow$}%
  \settoheight{\dimen\tw@}{$\m@th#1\rightarrow$}%
  \sbox\z@{%
    \makebox[\dimen\z@][s]{%
      \clipbox{0 0 {0.4\width} 0}%
        {\resizebox{\dimen\z@}{\height}%
          {$\m@th#1\dashrightarrow$}}%
      \hss%
      \clipbox{{0.69\width} {-0.1\height} 0
        {-\height}}{$\m@th#1\rightarrow$}%
    }%
  }%
  \ht\z@=\dimen\tw@ \dp\z@=\z@%
  \box\z@%
  \endgroup}\makeatother



\endinput
%%
%% End of file `eolang.sty'.
